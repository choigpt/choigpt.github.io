---
layout: post
title: "OSI 7계층, 진짜로 이해하기"
date: 2026-02-25 00:00:00
tags: [네트워크, CS, OSI, TCP/IP]
category: CS
---

## 1계층 — 물리 계층 (Physical Layer)

### 두 컴퓨터가 통신하려면?

모든 파일과 프로그램은 **0과 1의 나열**입니다. 두 컴퓨터가 통신한다는 건, 결국 0과 1을 주고받을 수 있으면 됩니다.

- `1`을 보낼 때 → **+5V** 전기를 흘려보낸다
- `0`을 보낼 때 → **-5V** 전기를 흘려보낸다

이론상 완벽해 보이지만, 실제로는 잘 동작하지 않습니다. 디지털 신호는 **0Hz ~ 무한대Hz**의 주파수 범위를 가지는데, 전선은 특정 범위의 주파수만 통과시킬 수 있기 때문입니다.

### 해결책: 아날로그 신호로 변환

디지털 신호를 **아날로그 신호로 바꿔서** 전송합니다.

- **인코딩**: 0/1 나열 → 아날로그 신호
- **디코딩**: 아날로그 신호 → 0/1 나열

이 과정을 담당하는 것이 바로 **1계층, 물리 계층**입니다.

> 💡 구현 위치: **PHY 칩** (하드웨어)

---

## 잠깐, 여러 대의 컴퓨터는 어떻게 연결하나?

전선 하나를 여러 컴퓨터가 공유하는 방식을 씁니다. 그런데 여기서 문제가 생깁니다. 전기 신호는 전선 전체로 퍼지기 때문에, **A가 B에게 보낸 메시지를 C, D도 전부 받아버립니다.**

### 스위치(Switch): 원하는 곳에만 전달하기

이 문제를 해결하기 위해 등장한 것이 **스위치**입니다. 스위치는 중간에서 메시지를 가로채어 **목적지 주소를 확인한 뒤, 해당 컴퓨터에게만 전달**합니다.

스위치 하나로 묶인 컴퓨터들이 **하나의 네트워크**입니다. 서로 다른 네트워크끼리는 **라우터**로 연결하고, 이것을 전 세계 규모로 확장한 것이 **인터넷**입니다.

---

## 2계층 — 데이터 링크 계층 (Data Link Layer)

### 해결책: 프레임(Frame)으로 감싸기

송신자는 데이터의 앞뒤에 **특정 비트열(플래그)**을 붙입니다.

| 시작 플래그 | 데이터 | 끝 플래그 |
|:-----------:|:------:|:---------:|
| `01111110` | `0 0 1 0 0 1 0 1` | `01111110` |

수신자는 `0x7E(01111110)` 패턴을 찾아 데이터 경계를 구분합니다. 이렇게 원본 데이터를 앞뒤 플래그로 감싼 것을 **프레임(Frame)**, 이 과정을 **프레이밍(Framing)**이라 합니다.

> 💡 구현 위치: **랜카드 / NIC** (하드웨어)

---

## 3계층 — 네트워크 계층 (Network Layer)

### 해결책: IP 주소와 패킷(Packet)

각 컴퓨터는 고유한 **IP 주소**를 가집니다. 송신자는 데이터 앞에 목적지 IP 주소를 붙이고, 이것을 **패킷(Packet)**이라 합니다.

각 라우터는 패킷을 열어 목적지 IP를 확인하고, 다음 라우터를 결정합니다. 이 과정이 **라우팅**입니다.

> 💡 IP는 "최선을 다해 보낸다(Best Effort)"는 철학입니다. 신뢰성이 필요하면 4계층 TCP와 함께 씁니다.

### TTL(Time To Live)

패킷이 네트워크를 무한히 떠돌지 못하게 막는 안전장치입니다. 라우터를 하나 지날 때마다 1씩 줄어들고, 0이 되면 드롭합니다.

> 💡 구현 위치: **OS 커널** (소프트웨어)

---

## 4계층 — 전송 계층 (Transport Layer)

### 해결책: 포트 번호(Port Number)

각 프로세스는 **포트 번호**라는 고유한 번호를 가집니다. `www.naver.com` 뒤에 숨겨진 `:80`도 포트 번호입니다.

### TCP (Transmission Control Protocol)

> 💡 IP가 "그냥 보낸다"면, TCP는 "제대로 보낸다"입니다. 유실되면 재전송, 순서가 바뀌면 정렬, 수신자가 벅차면 속도를 줄입니다.

### 3-Way Handshake (연결 수립)

```
클라이언트 → SYN (SEQ=x)              → 서버
클라이언트 ← SYN + ACK (SEQ=y, ACK=x+1) ← 서버
클라이언트 → ACK (ACK=y+1)             → 서버
ESTABLISHED                         ESTABLISHED
```

### 4-Way Handshake (연결 해제)

```
클라이언트 → FIN                       → 서버
클라이언트 ← ACK                       ← 서버
클라이언트 ← FIN                       ← 서버
클라이언트 → ACK                       → 서버
[TIME_WAIT → CLOSED]                   [CLOSED]
```

> 💡 구현 위치: **OS 커널** (소프트웨어)

---

## 5~7계층 — 응용 계층 (Application Layer)

현대 인터넷은 TCP/IP 모델을 따르며, OSI의 5·6·7계층은 하나의 **응용 계층**으로 합쳐집니다.

응용 계층의 대표적인 프로토콜이 **HTTP**입니다.

> 💡 구현 위치: **애플리케이션** (소프트웨어)

---

## 전체 흐름 정리

```
송신                              수신
원본 데이터                         원본 데이터 수신 ✅
↓ 7계층: HTTP 헤더 추가            ↑ 7계층: HTTP 파싱
↓ 4계층: 포트 번호 추가            ↑ 4계층: 포트 번호로 프로세스 식별
↓ 3계층: IP 주소 추가              ↑ 3계층: IP 확인 및 제거
↓ 2계층: 프레임 플래그 추가        ↑ 2계층: 프레임 플래그 제거
↓ 1계층: 아날로그 신호로 변환      ↑ 1계층: 0과 1로 해석
         〰️ 전선 〰️
```

---

## 각 계층 요약

| 계층 | 이름 | 핵심 역할 | 구현 위치 | 핵심 개념 |
|:----:|------|-----------|-----------|-----------|
| 1 | 물리 계층 | 0/1 ↔ 아날로그 신호 | 하드웨어 (PHY 칩) | 인코딩 / 디코딩 |
| 2 | 데이터 링크 계층 | 같은 네트워크 내 통신 | 하드웨어 (랜카드) | 프레임, 프레이밍 |
| 3 | 네트워크 계층 | 인터넷 상의 목적지 탐색 | OS 커널 | IP, 패킷, 라우팅, TTL |
| 4 | 전송 계층 | 목적지 프로세스로 전달 | OS 커널 | 포트 번호, TCP, 소켓 |
| 5~7 | 응용 계층 | 애플리케이션 간 통신 규약 | 애플리케이션 | HTTP, DNS 등 |
